-- ============================================================
-- EZSTORAGE Phase 1 Migration
-- Run this in your Supabase SQL Editor before using Phase 1 modules
-- ============================================================

-- 1. Create job_type enum for Phase 1
DO $$ BEGIN
  CREATE TYPE phase1_job_type AS ENUM ('Move', 'Store', 'Dispose', 'Other');
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- 2. Create kanban_column enum
DO $$ BEGIN
  CREATE TYPE kanban_column AS ENUM ('deals_closed', 'scheduled', 'enroute', 'inbound', 'completed');
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- 3. Create vendor enum
DO $$ BEGIN
  CREATE TYPE job_vendor AS ENUM ('Jean', 'GSX', 'MoveMove', 'Other');
EXCEPTION WHEN duplicate_object THEN NULL;
END $$;

-- 4. Create jobs table
CREATE TABLE IF NOT EXISTS jobs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  job_number VARCHAR(30) UNIQUE, -- e.g., JOB-2026-0001, auto-generated by trigger

  -- Customer link
  customer_id UUID NOT NULL REFERENCES customers(id) ON DELETE RESTRICT,

  -- Job details
  size_plan VARCHAR(255),
  job_type phase1_job_type NOT NULL DEFAULT 'Move',

  -- Pickup
  pickup_address TEXT,
  pickup_timing TIMESTAMPTZ,

  -- Destination
  destination_address TEXT,
  destination_timing TIMESTAMPTZ,

  -- Optional fields
  stopover TEXT,
  storage_location VARCHAR(255),
  volume VARCHAR(100),

  -- Vendor & Status
  assigned_vendor job_vendor DEFAULT 'Other',
  kanban_column kanban_column NOT NULL DEFAULT 'deals_closed',

  -- Notes
  internal_notes TEXT,

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 5. Auto-generate job number trigger
CREATE OR REPLACE FUNCTION generate_job_number()
RETURNS TRIGGER AS $$
DECLARE
  next_number INTEGER;
  current_year TEXT;
BEGIN
  current_year := EXTRACT(YEAR FROM CURRENT_DATE)::TEXT;

  SELECT COALESCE(MAX(CAST(SUBSTRING(job_number FROM 10) AS INTEGER)), 0) + 1
  INTO next_number
  FROM jobs
  WHERE job_number LIKE 'JOB-' || current_year || '-%';

  NEW.job_number := 'JOB-' || current_year || '-' || LPAD(next_number::TEXT, 4, '0');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS auto_job_number ON jobs;
CREATE TRIGGER auto_job_number BEFORE INSERT ON jobs
  FOR EACH ROW
  WHEN (NEW.job_number IS NULL)
  EXECUTE FUNCTION generate_job_number();

-- 6. Auto-update updated_at on jobs
DROP TRIGGER IF EXISTS update_jobs_updated_at ON jobs;
CREATE TRIGGER update_jobs_updated_at BEFORE UPDATE ON jobs
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- 7. Indexes
CREATE INDEX IF NOT EXISTS idx_jobs_customer ON jobs(customer_id);
CREATE INDEX IF NOT EXISTS idx_jobs_vendor ON jobs(assigned_vendor);
CREATE INDEX IF NOT EXISTS idx_jobs_kanban ON jobs(kanban_column);
CREATE INDEX IF NOT EXISTS idx_jobs_pickup_timing ON jobs(pickup_timing);
CREATE INDEX IF NOT EXISTS idx_jobs_created ON jobs(created_at DESC);

-- 8. RLS - Enable and allow authenticated users to access jobs
ALTER TABLE jobs ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if any
DROP POLICY IF EXISTS "Authenticated users can view jobs" ON jobs;
DROP POLICY IF EXISTS "Authenticated users can insert jobs" ON jobs;
DROP POLICY IF EXISTS "Authenticated users can update jobs" ON jobs;
DROP POLICY IF EXISTS "Authenticated users can delete jobs" ON jobs;

-- Allow all authenticated users to read
CREATE POLICY "Authenticated users can view jobs"
  ON jobs FOR SELECT
  TO authenticated
  USING (true);

-- Allow authenticated users to insert
CREATE POLICY "Authenticated users can insert jobs"
  ON jobs FOR INSERT
  TO authenticated
  WITH CHECK (true);

-- Allow authenticated users to update
CREATE POLICY "Authenticated users can update jobs"
  ON jobs FOR UPDATE
  TO authenticated
  USING (true)
  WITH CHECK (true);

-- Allow authenticated users to delete (frontend handles role restriction)
CREATE POLICY "Authenticated users can delete jobs"
  ON jobs FOR DELETE
  TO authenticated
  USING (true);

-- 9. Verify
SELECT 'Phase 1 migration complete! jobs table created.' AS status;
SELECT COUNT(*) AS job_count FROM jobs;
